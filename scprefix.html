<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>SCPrefix</title>
<!--
    scprefix.html
    2017-1-12 v1.41
-->
<style type="text/css">
<!--
.main_container {
    background-color: #fffca8; /* 背景色 */
    color: #000000;            /* 文字色 */
}
-->
</style>
<script type="text/javascript">
<!--
// ****************************************
//            ブラウザ関連処理等
// ****************************************

// ***** 汎用 *****
function Alm(msg) {
    // alert(msg);
}
function Alm2(msg) {
    alert(msg);
}
function DebugShow(msg) {
    document.getElementById("debug_show1").appendChild(document.createTextNode(msg));
}
function DebugShowClear() {
    document.getElementById("debug_show1").innerHTML = "";
}

// ***** 変換ボタン *****
function convert_button() {
    var ret;
    var src_st;
    var minus_conv;
    var line_feed;
    var result = {};

    // ***** 戻り値の初期化 *****
    ret = false;
    // ***** デバッグ表示の初期化 *****
    DebugShowClear();
    // ***** 要素の存在チェック *****
    if (!document.getElementById("src_text1"))    { Alm("convert_button:0001"); return ret; }
    if (!document.getElementById("minus_conv"))   { Alm("convert_button:0002"); return ret; }
    if (!document.getElementById("line_feed"))    { Alm("convert_button:0003"); return ret; }
    if (!document.getElementById("out_text1"))    { Alm("convert_button:0004"); return ret; }
    if (!document.getElementById("result_show1")) { Alm("convert_button:0005"); return ret; }
    // ***** ソースの取得 *****
    src_st = document.getElementById("src_text1").value;
    minus_conv = document.getElementById("minus_conv").checked;
    line_feed = document.getElementById("line_feed").checked;
    // ***** 変換実行 *****
    result = SCPrefix.convert(src_st, minus_conv, line_feed);
    // ***** 出力の表示 *****
    document.getElementById("out_text1").value = result.out;
    document.getElementById("result_show1").innerHTML = result.html;
    // ***** 戻り値を返す *****
    ret = true;
    return ret;
}

// ***** クリアボタン *****
function clear_button() {
    var ret;

    // ***** 戻り値の初期化 *****
    ret = false;
    // ***** デバッグ表示の初期化 *****
    DebugShowClear();
    // ***** 要素の存在チェック *****
    if (!document.getElementById("src_text1"))    { Alm("clear_button:0001"); return ret; }
    if (!document.getElementById("out_text1"))    { Alm("clear_button:0002"); return ret; }
    if (!document.getElementById("result_show1")) { Alm("clear_button:0003"); return ret; }
    // ***** ソースのクリア *****
    document.getElementById("src_text1").value = "";
    // ***** 出力のクリア *****
    document.getElementById("out_text1").value = "";
    document.getElementById("result_show1").innerHTML = "";
    // ***** 戻り値を返す *****
    ret = true;
    return ret;
}

// ***** サンプルボタン *****
function sample_button(sample_no) {
    var ret;
    var src_st;

    // ***** 戻り値の初期化 *****
    ret = false;
    // ***** 要素の存在チェック *****
    if (!document.getElementById("src_text1")) { Alm("sample_button:0001"); return ret; }
    // ***** ソースの設定 *****
    src_st = "";
    switch (sample_no) {
        case 0:
            src_st = "1*2+3*4+5*6\n";
            break;
        case 1:
            src_st = "// Euler's formula\n"
                + "define(pi, 3.141592653589793);\n"
                + "define(x,  pi /. 6);\n"
                + "define(y1, 0);\n"
                + "define(y2, 0);\n"
                + "y1=exp({%+i%}*x);\n"
                + "y2=cos(x)+{%+i%}*sin(x);\n";
            break;
        case 2:
            src_st = "// Array sample\n"
                + "define(a, {%'((1 2 3) (4 5 6) (7 8 9))%});\n"
                + "print(a[0][0], \" \", a[0][1], \" \", a[0][2]);\n"
                + "print(a[1][0], \" \", a[1][1], \" \", a[1][2]);\n"
                + "print(a[2][0], \" \", a[2][1], \" \", a[2][2]);\n";
            break;
    }
    document.getElementById("src_text1").value = src_st;
    // ***** 変換ボタンを押したことにする *****
    convert_button();
    // ***** 戻り値を返す *****
    ret = true;
    return ret;
}


// ****************************************
//          中置記法→前置記法変換
// ****************************************

// ***** SCPrefix(名前空間) *****
//
// 公開I/F :
//
//   SCPrefix.convert(src_st, minus_conv, line_feed)  変換実行
//     src_st      ソース(文字列)
//     minus_conv  マイナス変換フラグ(boolean)
//                   (-を+-に変換することで、多項式の変換結果を若干見やすくする)
//     line_feed   改行(+コメント)反映フラグ(boolean)
//     戻り値      結果オブジェクト
//                   result.out   テキスト出力(文字列)
//                   result.html  HTML出力(文字列)
//
var SCPrefix;
(function (SCPrefix) {
    // ***** 定数 *****
    var operator_data = [ // 演算子データ
        // 演算子, 変換名, 優先順位, キャスト判定用
        ["(",      "(",          0,     0],
        [")",      ")",          0,     0],
        ["{",      "{",          0,     0],
        ["}",      "}",          0,     0],
        ["[",      "[",          0,     0],
        ["]",      "]",          0,     0],
        ["->",     "->",       100,     0],
        ["++",     "inc!",       0,     1],
        ["--",     "dec!",       0,     1],
        ["**",     "expt",      90,     0],
        ["!",      "not",        0,     1],
        ["~",      "lognot",     0,     1],
        // ["&",      "&",          0,     1], // 単項
        // ["*",      "*",          0,     1], // 単項
        // ["+",      "+",          0,     1], // 単項
        // ["-",      "-",          0,     1], // 単項
        // ["+.",     "+.",         0,     1], // 単項
        // ["-.",     "-.",         0,     1], // 単項
        ["*",      "*",         40,     0],
        ["/",      "/",         40,     0],
        ["*.",     "*.",        40,     0],
        ["/.",     "/.",        40,     0],
        ["\\",     "quotient",  40,     0],
        ["%",      "modulo",    40,     0],
        ["+",      "+",         30,     0],
        ["-",      "-",         30,     0],
        ["+.",     "+.",        30,     0],
        ["-.",     "-.",        30,     0],
        ["%%",     "string-append", 30, 0],
        ["<<",     "ash",       25,     0],
        [">>",     "ash",       25,     0], // (ash n1 (- n2))
        ["<",      "<",         20,     0],
        ["<=",     "<=",        20,     0],
        [">",      ">",         20,     0],
        [">=",     ">=",        20,     0],
        ["==",     "=",         20,     0],
        ["!=",     "=",         20,     0], // (not (= n1 n2))
        ["&",      "logand",    15,     0],
        ["|",      "logior",    15,     0],
        ["^",      "logxor",    15,     0],
        ["&&",     "and",       10,     0],
        ["||",     "or",        10,     0],
        ["?",      "if",        10,     0],
        [":",      ":",         10,     0],
        [",",      ",",          0,     0],
        ["=",      "set!",       0,     0],
        ["*=",     "*=",         0,     0],
        ["/=",     "/=",         0,     0],
        ["*.=",    "*.=",        0,     0],
        ["/.=",    "/.=",        0,     0],
        ["+=",     "+=",         0,     0],
        ["-=",     "-=",         0,     0],
        ["+.=",    "+.=",        0,     0],
        ["-.=",    "-.=",        0,     0],
        ["%%=",    "%%=",        0,     0],
        ["\\=",    "\\=",        0,     0],
        ["%=",     "%=",         0,     0],
        ["<<=",    "<<=",        0,     0],
        [">>=",    ">>=",        0,     0],
        ["&=",     "&=",         0,     0],
        ["|=",     "|=",         0,     0],
        ["^=",     "^=",         0,     0]];

    // ***** 変数 *****
    var src_st;              // ソース(文字列)
    var minus_conv;          // マイナス変換フラグ(boolean)
    var line_feed;           // 改行(+コメント)反映フラグ(boolean)
    var out_st;              // テキスト出力(文字列)
    var html_st;             // HTML出力(文字列)
    var operator_table = {}; // 演算子情報(連想配列オブジェクト)
                             //   operator_table[op].funcname  変換名
                             //   operator_table[op].priority  優先順位(大きいほど優先,0は無効)
                             //   operator_table[op].castflag  キャスト判定用(要修正)
    var token = [];          // トークン(配列)
                             //   token[i].kind     種別(=0:改行,
                             //                          =51:1行コメント,
                             //                          =52:複数行コメント,
                             //                          =100:その他)
                             //   token[i].word     単語(文字列)
                             //   token[i].line_no  行番号(1オリジン)
    var code = [];           // コード(配列)
                             //   code[i].word      単語(文字列)
                             //   code[i].pos1      デバッグ位置1
                             //   code[i].pos2      デバッグ位置2
                             //   code[i].opt       最適化用情報
    var debugpos1;           // デバッグ位置1
    var debugpos2;           // デバッグ位置2
    var line_feed_num;       // 未出力の改行(+コメント)数
    var line_feed_code = []; // 未出力の改行(+コメント)(配列)

    // ***** 公開I/F *****

    // ***** 変換実行 *****
    function convert(src_st1, minus_conv1, line_feed1) {
        var result = {}; // 戻り値

        // ***** 戻り値の初期化 *****
        result = {};
        result.out = "";
        result.html = "";
        // ***** 引数のチェック *****
        if (src_st1 == null)     { Alm("SCPrefix.convert:0001"); return result; }
        if (minus_conv1 == null) { Alm("SCPrefix.convert:0002"); return result; }
        if (line_feed1 == null)  { Alm("SCPrefix.convert:0003"); return result; }
        // ***** ソースの取得 *****
        src_st = src_st1;
        // ***** マイナス変換フラグの取得 *****
        minus_conv = minus_conv1;
        // ***** 改行(+コメント)反映フラグの取得 *****
        line_feed = line_feed1;
        // ***** 演算子情報の生成 *****
        make_optable();
        // ***** トークン分割 *****
        tokenize();
        // ***** コンパイル *****
        compile();
        // ***** 出力の生成 *****
        make_output();
        // ***** 戻り値を返す *****
        result.out = out_st;
        result.html = html_st;
        return result;
    }
    SCPrefix.convert = convert;

    // ***** 公開I/Fはここまで *****

    // ***** 以下は内部処理用 *****

    // ***** 出力の生成 *****
    function make_output() {
        var i;

        // ***** 出力の生成(サブ) *****
        function make_output_sub(escape_func) {
            var i;
            var output_st;   // 出力文字列
            var code_len;    // コード数
            var arr_st = []; // 文字列の配列

            // ***** 出力の生成(サブ) *****
            output_st = "";
            arr_st = [];
            code_len = code.length;
            for (i = 0; i < code_len; i++) {
                // ***** 前方の空白を追加 *****
                if (i > 0 &&
                    !(code[i - 1].word == "(" || code[i].word == ")" ||
                    code[i - 1].word == "\n" || code[i].word == "\n")) {
                    arr_st.push(" ");
                }
                // ***** 単語を追加 *****
                arr_st.push(escape_func ? escape_func(code[i].word) : code[i].word);
            }
            output_st = arr_st.join("");
            return output_st;
        }

        // ***** テキスト出力の生成 *****
        out_st = make_output_sub(null);

        // ***** HTML出力の生成 *****
        // (単語をサニタイズ(タグ無効化)してから追加)
        html_st = make_output_sub(escape_html);

        // ***** デバッグ表示 *****
        if (0) {
            DebugShow("token:\n");
            for (i = 0; i < token.length; i++) {
                DebugShow(JSON.stringify(token[i]) + "\n");
            }
            DebugShow("code:\n");
            for (i = 0; i < code.length; i++) {
                DebugShow(JSON.stringify(code[i]) + "\n");
            }
        }
    }

    // ***** コンパイル *****
    function compile() {
        var i;
        var msg;
        var err_line1;
        var err_line2;
        var tok_end;
        var last_lf_num;

        // ***** コンパイル *****
        code = [];
        debugpos1 = 0;
        debugpos2 = 0;
        line_feed_num = 0;
        line_feed_code = [];
        try {
            // ***** 文(ステートメント)のコンパイル *****
            tok_end = token.length - 4; // 終端4個分マイナス
            last_lf_num = 0;
            while (tok_end > 0) {
                // ***** 末尾の改行(+コメント)を削除 *****
                // (改行(+コメント)のスキップにより、1回多くトークンを
                //  読み込んでしまうことを回避するため)
                if (token[tok_end - 1].kind == 0  ||
                    token[tok_end - 1].kind == 51 ||
                    token[tok_end - 1].kind == 52) {
                    last_lf_num++;
                    tok_end--;
                    continue;
                }
                break;
            }
            c_statement(0, tok_end);
            if (line_feed) {
                // ***** 末尾の改行(+コメント)を戻す *****
                for (i = 0; i < last_lf_num; i++) {
                    code_push(token[tok_end + i].word, debugpos1, tok_end);
                }
            }
            for (i = 0; i < code.length; i++) {
                // ***** 生成コードに終端がまざっていたとき *****
                if (code[i].word == "%end") {
                    debugpos2 = tok_end;
                    throw new Error("文が未完成です。");
                }
            }
        } catch (ex) {
            // ***** 構文エラーのとき *****
            DebugShow("構文エラー: " + ex.message + ": debugpos=" + debugpos1 + "\n");
            err_line1 = token[debugpos1].line_no;
            msg = "エラー場所: " + err_line1 + "行";
            err_line2 = 0;
            if (debugpos1 < debugpos2) {
                if (debugpos2 - 1 < tok_end) {
                    err_line2 = token[debugpos2 - 1].line_no;
                }
            } else {
                debugpos2 = debugpos1 + 1;
            }
            if (err_line1 < err_line2) {
                msg += " - " + err_line2 + "行 の解析中に検出:\n";
            } else {
                msg += ": ";
            }
            for (i = debugpos1; i < debugpos2; i++) {
                if (i >= 0 && i < tok_end) {
                    msg = msg + token[i].word + " ";
                }
            }
            if (err_line1 < err_line2) {
                msg += "\n===== エラー場所 ここまで =====\n";
            } else {
                msg += "\n";
            }
            DebugShow(msg);
        }
        // ***** 後処理 *****
        for (i = 0; i < code.length; i++) {
            // (最適化処理 : begin,begin0のリネームを元に戻す)
            if (code[i].word == "%begin") {
                code[i].word = "begin";
                continue;
            }
            if (code[i].word == "%begin0") {
                code[i].word = "begin0";
                continue;
            }
            // (終端処理 : エラー表示用)
            if (code[i].word == "%end") {
                code[i].word = "";
                continue;
            }
            // (波括弧処理 : 開き波括弧を外す)
            if (code[i].word.substring(0, 2) == "{%") {
                code[i].word = code[i].word.substring(2);
                continue;
            }
        }
    }
    // ***** 文(ステートメント)のコンパイル *****
    function c_statement(tok_start, tok_end) {
        var i;
        var tok;
        var code_pos1;
        var opt_val;

        // ***** トークン解析のループ *****
        i = tok_start;
        while (i < tok_end) {
            // ***** トークン取り出し *****
            i = skip_line_feed(i, tok_end);
            output_line_feed(i);
            debugpos1 = i;
            tok = token[i].word;
            // ***** セミコロン,カンマ,終端のとき(要修正) *****
            if (tok == ";" ||
                tok == "," ||
                tok == "%end") {
                i++;
                continue;
            }
            // ***** 式のコンパイル *****
            code_pos1 = code.length;
            i = c_expression(i, tok_end);
            // (最適化処理 : 代入のbegin,begin0を削除 (戻り値が不要のため))
            if (code_pos1 <= code.length - 4 && code[code_pos1].word == "(") {
                if (code[code_pos1 + 1].word == "%begin") {
                    opt_val = code[code_pos1 + 1].opt; // (変数の長さを取得)
                    code.splice(code_pos1, 2);
                    code.splice(code.length - (opt_val + 1), opt_val + 1);
                } else if (code[code_pos1 + 1].word == "%begin0") {
                    opt_val = code[code_pos1 + 1].opt; // (変数の長さを取得)
                    code.splice(code_pos1, 2 + opt_val);
                    code.splice(code.length - 1, 1);
                }
            }
            output_line_feed(i);
            if (!line_feed) {
                code_push("\n", debugpos1, i);
            }
        }
    }
    // ***** 式のコンパイル *****
    // (priority はオプション引数で、演算子の優先順位を表す。大きいほど優先順位が高い)
    function c_expression(tok_start, tok_end, priority) {
        var i;
        var tok;
        var code_pos1;

        // ***** 引数のチェック *****
        if (priority == null) { priority = 0; }
        // ***** 因子のコンパイル *****
        i = tok_start;
        i = skip_line_feed(i, tok_end);
        output_line_feed(i);
        code_pos1 = code.length;
        i = c_factor(i, tok_end);
        // ***** 演算子処理のループ *****
        while (i < tok_end) {
            // ***** トークン取り出し *****
            i = skip_line_feed(i, tok_end);
            // output_line_feed(i);
            // debugpos1 = i;
            tok = token[i].word;

            // ***** 論理AND,ORのとき *****
            // ***** ビットAND,OR,XORのとき *****
            // ***** 加減算のとき *****
            // ***** 乗除算のとき *****
            if ((
                tok == "&&" || tok == "||" ||
                tok == "&"  || tok == "|"  || tok == "^"  ||
                tok == "+"  || tok == "-"  || tok == "+." || tok == "-." || tok == "%%" ||
                tok == "*"  || tok == "/"  || tok == "*." || tok == "/.") && priority < op_pri(tok)) {
                i++;

                // (ポインタ型判定)(要修正)
                if (tok == "*") {
                    i = skip_line_feed(i, tok_end);
                    if (token[i].word == "," || token[i].word == ")") {
                        code_insert(code_pos1, "(", debugpos1, i);
                        // code_insert(code_pos1 + 1, op_func(tok), debugpos1, i);
                        code_insert(code_pos1 + 1, tok, debugpos1, i);
                        code_push(")", debugpos1, i);
                        continue;
                    }
                }

                code_insert(code_pos1, "(", debugpos1, i);
                code_insert(code_pos1 + 1, op_func(tok), debugpos1, i);
                i = c_expression(i, tok_end, op_pri(tok));
                // (最適化処理 : 同一演算子による計算をまとめる)
                while (i < tok_end) {
                    if (token[i].word != tok) { break; }
                    i++;
                    i = c_expression(i, tok_end, op_pri(tok));
                }
                code_push(")", debugpos1, i);
                continue;
            }

            // ***** 数値比較のとき *****
            // ***** 整数除算または整数剰余のとき *****
            // ***** 左ビットシフトのとき *****
            // ***** 間接メンバポインタのとき *****
            if ((
                tok == "<"  || tok == "<=" || tok == ">"  || tok == ">=" || tok == "==" ||
                tok == "\\" || tok == "%"  ||
                tok == "<<" ||
                tok == "->") && priority < op_pri(tok)) {
                i++;
                code_insert(code_pos1, "(", debugpos1, i);
                code_insert(code_pos1 + 1, op_func(tok), debugpos1, i);
                i = c_expression(i, tok_end, op_pri(tok));
                code_push(")", debugpos1, i);
                continue;
            }

            // ***** 3項演算子のとき *****
            if (tok == "?" && priority < op_pri(tok)) {
                i++;
                code_insert(code_pos1, "(", debugpos1, i);
                code_insert(code_pos1 + 1, op_func(tok), debugpos1, i);
                i = c_expression(i, tok_end, op_pri(tok) - 1); // 右結合
                match2(":", i++, tok_end);
                i = c_expression(i, tok_end, op_pri(tok) - 1); // 右結合

                // (区切りチェック)(要修正)
                // match2(";", i++, tok_end);
                i = skip_line_feed(i, tok_end);
                // output_line_feed(i);
                if (token[i].word == ";") { i++; }

                code_push(")", debugpos1, i);
                continue;
            }

            // ***** 非等価演算子のとき *****
            if (tok == "!=" && priority < op_pri(tok)) {
                i++;
                code_insert(code_pos1, "(", debugpos1, i);
                code_insert(code_pos1 + 1, "not", debugpos1, i);
                code_insert(code_pos1 + 2, "(", debugpos1, i);
                code_insert(code_pos1 + 3, op_func(tok), debugpos1, i);
                i = c_expression(i, tok_end, op_pri(tok));
                code_push(")", debugpos1, i);
                code_push(")", debugpos1, i);
                continue;
            }

            // ***** 右ビットシフトのとき *****
            if (tok == ">>" && priority < op_pri(tok)) {
                i++;
                code_insert(code_pos1, "(", debugpos1, i);
                code_insert(code_pos1 + 1, op_func(tok), debugpos1, i);
                code_push("(", debugpos1, i);
                code_push("-", debugpos1, i);
                i = c_expression(i, tok_end, op_pri(tok));
                code_push(")", debugpos1, i);
                code_push(")", debugpos1, i);
                continue;
            }

            // (べき乗の処理は、単項の負符号より強くするため c_factor に移動)
            // ***** べき乗のとき *****
            // if (tok == "**" && priority < op_pri(tok)) {
            //     i++;
            //     code_insert(code_pos1, "(", debugpos1, i);
            //     code_insert(code_pos1 + 1, op_func(tok), debugpos1, i);
            //     i = c_expression(i, tok_end, op_pri(tok) - 1); // 右結合
            //     code_push(")", debugpos1, i);
            //     continue;
            // }

            // ***** 演算子処理のループを抜ける *****
            break;
        }
        // ***** 戻り値を返す *****
        return i;
    }
    // ***** 因子のコンパイル *****
    function c_factor(tok_start, tok_end) {
        var i, i2;
        var tok;
        var code_pos1;
        var code_pos2;
        var close_paren_ch;
        var comma_count;
        var var_name;
        var op;
        var pre_flag;
        var pre_op;
        var opt_val;

        // ***** トークン取り出し *****
        i = tok_start;
        i = skip_line_feed(i, tok_end);
        output_line_feed(i);
        // debugpos1 = i;
        code_pos1 = code.length;
        tok = token[i].word;
        // ***** 文字列リテラルのとき *****
        if (tok.charAt(0) == '"' || tok.charAt(0) == "'") {
            i++;
            code_push(tok, debugpos1, i);
            return i;
        }
        // ***** ポインタ,アドレスのとき(要修正) *****
        if (tok == "*" || tok == "&") {
            i++;
            code_push("(", debugpos1, i);
            code_push(tok, debugpos1, i);
            i = c_factor(i, tok_end);
            code_push(")", debugpos1, i);
            return i;
        }
        // ***** 論理NOT,ビットNOT *****
        // ***** 正符号,負符号のとき *****
        // ***** 不正確数正符号,不正確数負符号のとき *****
        if (tok == "!"  || tok == "~" ||
            tok == "+"  || tok == "-" ||
            tok == "+." || tok == "-.") {
            i++;
            code_push("(", debugpos1, i);
            code_push(op_func(tok), debugpos1, i);
            i = c_factor(i, tok_end);
            code_push(")", debugpos1, i);
            return i;
        }
        // // ***** 正符号のとき *****
        // if (tok == "+") {
        //     i++;
        //     i = c_factor(i, tok_end);
        //     return i;
        // }

        // ***** プレINC,DECのとき *****
        if (tok == "++" || tok == "--") {
            i++;
            pre_flag = true;
            pre_op = tok;
        } else {
            pre_flag = false;
            pre_op = "";
        }

        // ***** トークン取り出し *****
        i = skip_line_feed(i, tok_end);
        // output_line_feed(i);
        code_pos1 = code.length;
        tok = token[i].word;
        // ***** 括弧のとき *****
        if (tok == "(" || tok == "{") {
            if (tok == "(") {
                close_paren_ch = ")";
            } else {
                close_paren_ch = "}";
            }
            i++;
            // ***** 式のコンパイル *****
            code_push("(", debugpos1, i);
            code_push("begin", debugpos1, i);
            i = skip_line_feed(i, tok_end);
            output_line_feed(i);
            code_pos2 = code.length;
            // if (token[i].word != close_paren_ch) {
            //     i = c_expression(i, tok_end);
            // }
            // ***** カンマ区切りの処理 *****
            comma_count = -1;
            while (i < tok_end) {
                i = skip_line_feed(i, tok_end);
                // output_line_feed(i);

                // (区切りチェック)(要修正)
                if (token[i].word == close_paren_ch) { break; }
                if (token[i].word == "," || token[i].word == ";") {
                    i++;
                    continue;
                }

                comma_count++;
                // (最適化処理 : 代入のbegin,begin0を削除 (戻り値が不要のため))
                if (code_pos2 <= code.length - 4 && code[code_pos2].word == "(") {
                    if (code[code_pos2 + 1].word == "%begin") {
                        opt_val = code[code_pos2 + 1].opt; // (変数の長さを取得)
                        code.splice(code_pos2, 2);
                        code.splice(code.length - (opt_val + 1), opt_val + 1);
                    } else if (code[code_pos2 + 1].word == "%begin0") {
                        opt_val = code[code_pos2 + 1].opt; // (変数の長さを取得)
                        code.splice(code_pos2, 2 + opt_val);
                        code.splice(code.length - 1, 1);
                    }
                }
                // ***** 式のコンパイル *****
                i = skip_line_feed(i, tok_end);
                output_line_feed(i);
                code_pos2 = code.length;
                i = c_expression(i, tok_end);
            }
            match2(close_paren_ch, i++, tok_end);
            output_line_feed(i);

            // (キャスト判定)(要修正)
            if (close_paren_ch == ")" &&
                token[i].word != ";" &&
                token[i].word != "%end" &&
                token[i].kind != 0  &&
                token[i].kind != 51 &&
                token[i].kind != 52 &&
                (operator_table.hasOwnProperty(token[i].word) ?
                 operator_table[token[i].word].castflag == 1 : true)) {
                code.splice(code_pos1 + 1, 1);
                i = c_factor(i, tok_end);
                code_push(")", debugpos1, i);
                return i;
            }

            if (comma_count <= 0 && close_paren_ch == ")") {
                // (最適化処理 : 括弧のbeginを削除 (式が1個しかないため))
                code.splice(code_pos1, 2);
            } else {
                code_push(")", debugpos1, i);
            }
        // ***** 括弧以外のとき *****
        } else {
            // ***** 名前の取得 *****
            var_name = tok;
            code_push(var_name, debugpos1, i);
            i++;
            // (演算子チェック)(要修正)
            if (var_name != ":" &&
                var_name != "{" &&
                var_name != "}" &&
                var_name != "[" &&
                var_name != "]" &&
                operator_table.hasOwnProperty(var_name)) {
                debugpos2 = i;
                throw new Error("不正な位置に演算子 '" + var_name + "' が見つかりました。");
            }
        }

        // ***** トークン取り出し *****
        i = skip_line_feed(i, tok_end);
        // output_line_feed(i);
        tok = token[i].word;
        // ***** 関数のとき *****
        if (tok == "(") {
            i++;
            code_insert(code_pos1, "(", debugpos1, i);
            // ***** 引数の取得 *****
            while (i < tok_end) {
                i = skip_line_feed(i, tok_end);
                // output_line_feed(i);

                // (区切りチェック)(要修正)
                if (token[i].word == ")") { break; }
                if (token[i].word == "," || token[i].word == ";") {
                    i++;
                    continue;
                }

                i = c_expression(i, tok_end);
            }
            match2(")", i++, tok_end);
            output_line_feed(i);
            code_push(")", debugpos1, i);
        }

        // ***** トークン取り出し *****
        i = skip_line_feed(i, tok_end);
        // output_line_feed(i);
        tok = token[i].word;
        // ***** 配列のとき *****
        if (tok == "[") {
            // i++;
            code_insert(code_pos1, "(", debugpos1, i);
            code_insert(code_pos1 + 1, "~", debugpos1, i);
            // ***** 添字の取得 *****
            while (i < tok_end) {
                i = skip_line_feed(i, tok_end);
                // output_line_feed(i);
                if (token[i].word != "[") { break; }
                i++;
                i = skip_line_feed(i, tok_end);
                // output_line_feed(i);
                if (token[i].word != "]") {
                    i = c_expression(i, tok_end);
                }
                match2("]", i++, tok_end);
            }
            // output_line_feed(i);
            code_push(")", debugpos1, i);
        }

        // ***** プレINC,DECのとき *****
        if (pre_flag) {
            code_insert(code_pos1, "(", debugpos1, i);
            // (最適化処理 : 最適化用にbeginをリネーム)
            code_insert(code_pos1 + 1, "%begin", debugpos1, i);
            code_insert(code_pos1 + 2, "(", debugpos1, i);
            code_insert(code_pos1 + 3, op_func(pre_op), debugpos1, i);
            code_pos2 = code.length;
            code[code_pos1 + 1].opt = code_pos2 - (code_pos1 + 4); // (変数の長さを保存)
            code_push(")", debugpos1, i);
            // code_push(var_name, debugpos1, i);
            for (i2 = code_pos1 + 4; i2 < code_pos2; i2++) {
                code_push(code[i2].word, debugpos1, i);
            }
            code_push(")", debugpos1, i);
        }

        // ***** トークン取り出し *****
        i = skip_line_feed(i, tok_end);
        // output_line_feed(i);
        tok = token[i].word;
        // ***** ポストINC,DECのとき *****
        if ((tok == "++" || tok == "--") && !pre_flag) {
            i++;
            code_insert(code_pos1, "(", debugpos1, i);
            // (最適化処理 : 最適化用にbegin0をリネーム)
            code_insert(code_pos1 + 1, "%begin0", debugpos1, i);
            code_pos2 = code.length;
            code[code_pos1 + 1].opt = code_pos2 - (code_pos1 + 2); // (変数の長さを保存)
            code_push("(", debugpos1, i);
            code_push(op_func(tok), debugpos1, i);
            // code_push(var_name, debugpos1, i);
            for (i2 = code_pos1 + 2; i2 < code_pos2; i2++) {
                code_push(code[i2].word, debugpos1, i);
            }
            code_push(")", debugpos1, i);
            code_push(")", debugpos1, i);
        }

        // ***** トークン取り出し *****
        i = skip_line_feed(i, tok_end);
        // output_line_feed(i);
        tok = token[i].word;
        // ***** 代入のとき *****
        if (tok == "=") {
            i++;
            code_insert(code_pos1, "(", debugpos1, i);
            // (最適化処理 : 最適化用にbeginをリネーム)
            code_insert(code_pos1 + 1, "%begin", debugpos1, i);
            code_insert(code_pos1 + 2, "(", debugpos1, i);
            code_insert(code_pos1 + 3, op_func(tok), debugpos1, i);
            code_pos2 = code.length;
            code[code_pos1 + 1].opt = code_pos2 - (code_pos1 + 4); // (変数の長さを保存)
            i = c_expression(i, tok_end);
            code_push(")", debugpos1, i);
            // code_push(var_name, debugpos1, i);
            for (i2 = code_pos1 + 4; i2 < code_pos2; i2++) {
                code_push(code[i2].word, debugpos1, i);
            }
            code_push(")", debugpos1, i);
            return i;
        }
        // ***** 複合代入のとき *****
        if (tok == "+="  || tok == "-="  || tok == "+.=" || tok == "-.=" || tok == "%%=" ||
            tok == "*="  || tok == "/="  || tok == "*.=" || tok == "/.=" ||
            tok == "\\=" || tok == "%="  || tok == "<<=" || tok == ">>=" ||
            tok == "&="  || tok == "|="  || tok == "^=") {
            i++;
            code_insert(code_pos1, "(", debugpos1, i);
            // (最適化処理 : 最適化用にbeginをリネーム)
            code_insert(code_pos1 + 1, "%begin", debugpos1, i);
            code_insert(code_pos1 + 2, "(", debugpos1, i);
            code_insert(code_pos1 + 3, op_func("="), debugpos1, i);
            code_pos2 = code.length;
            code[code_pos1 + 1].opt = code_pos2 - (code_pos1 + 4); // (変数の長さを保存)
            code_push("(", debugpos1, i);
            op = tok.substring(0, tok.length - 1);
            code_push(op_func(op), debugpos1, i);
            // code_push(var_name, debugpos1, i);
            for (i2 = code_pos1 + 4; i2 < code_pos2; i2++) {
                code_push(code[i2].word, debugpos1, i);
            }
            if (op == ">>") {
                code_push("(", debugpos1, i);
                code_push("-", debugpos1, i);
                i = c_expression(i, tok_end);
                code_push(")", debugpos1, i);
            } else {
                i = c_expression(i, tok_end);
            }
            code_push(")", debugpos1, i);
            code_push(")", debugpos1, i);
            // code_push(var_name, debugpos1, i);
            for (i2 = code_pos1 + 4; i2 < code_pos2; i2++) {
                code_push(code[i2].word, debugpos1, i);
            }
            code_push(")", debugpos1, i);
            return i;
        }

        // ***** べき乗の処理 *****
        i = c_power(i, tok_end, code_pos1);

        // ***** 戻り値を返す *****
        return i;
    }
    // ***** べき乗の処理 *****
    // (単項の負符号より強くするため特別扱い)
    function c_power(tok_start, tok_end, code_pos1) {
        var i;
        var tok;

        // ***** トークン取り出し *****
        i = tok_start;
        i = skip_line_feed(i, tok_end);
        // output_line_feed(i);
        tok = token[i].word;
        // ***** べき乗のとき *****
        if (tok == "**") {
            i++;

            // (ポインタ型判定)(要修正)
            i = skip_line_feed(i, tok_end);
            if (token[i].word == "," || token[i].word == ")") {
                code_insert(code_pos1, "(", debugpos1, i);
                // code_insert(code_pos1 + 1, op_func(tok), debugpos1, i);
                code_insert(code_pos1 + 1, tok, debugpos1, i);
                code_push(")", debugpos1, i);
                return i;
            }

            code_insert(code_pos1, "(", debugpos1, i);
            code_insert(code_pos1 + 1, op_func(tok), debugpos1, i);
            i = c_factor(i, tok_end);
            code_push(")", debugpos1, i);
        }
        return i;
    }

    // ***** トークン分割 *****
    function tokenize() {
        var i, j;
        var i_start;    // 単語の開始位置
        var src_st_len; // ソースの長さ
        var ch, ch2;    // 文字
        var line_no;    // 行番号(1オリジン)
        var line_no_tk; // トークン開始時点の行番号
        var temp_st;    // 作業用文字列
        var delim_ch;   // デリミタ文字

        // ***** トークン追加 *****
        function token_push(kind, word) {
            var tk = {};
            tk.kind = kind;
            if (word == null) {
                tk.word = src_st.substring(i_start, i);
            } else {
                tk.word = word;
            }
            tk.line_no = line_no_tk;
            token.push(tk);
        }

        // ***** トークン分割 *****
        token = [];
        i = 0;
        line_no = 1;
        src_st_len = src_st.length;
        while (i < src_st_len) {
            // ***** 開始情報更新 *****
            i_start = i;
            line_no_tk = line_no;
            // ***** 1文字取り出す *****
            ch = src_st.charAt(i++);
            if (i < src_st_len) { ch2 = src_st.charAt(i); } else { ch2 = ""; }
            // ***** 空白かTABのとき *****
            if (ch == " " || ch == "\t") { continue; }
            // ***** 改行のとき *****
            if (ch == "\r" || ch == "\n") {
                line_no++;
                if (ch == "\r" && ch2 == "\n") { i++; }
                token_push(0, "\n");
                continue;
            }
            // ***** プリプロセッサ「#」のとき *****
            // ***** コメント「//」のとき *****
            if (ch == "#" || (ch == "/" && ch2 == "/")) {
                if (ch == "/" && ch2 == "/") { i++; }
                while (i < src_st_len) {
                    // ***** 1文字取り出す *****
                    ch = src_st.charAt(i++);
                    if (i < src_st_len) { ch2 = src_st.charAt(i); } else { ch2 = ""; }
                    // ***** 行継続のとき *****
                    if (ch == "\\") {
                        while (i < src_st_len) {
                            // ***** 1文字取り出す *****
                            ch = src_st.charAt(i++);
                            if (i < src_st_len) { ch2 = src_st.charAt(i); } else { ch2 = ""; }
                            // ***** 空白かTABのとき *****
                            if (ch == " " || ch == "\t") { continue; }
                            // ***** 改行のとき *****
                            if (ch == "\r" || ch == "\n") {
                                temp_st = ";; " + src_st.substring(i_start, i - 1);
                                token_push(51, temp_st);
                                line_no++;
                                if (ch == "\r" && ch2 == "\n") { i++; }
                                token_push(0, "\n");
                                // ***** 開始情報更新 *****
                                i_start = i;
                                line_no_tk = line_no;
                            }
                            break;
                        }
                        continue;
                    }
                    // ***** 改行のとき *****
                    if (ch == "\r" || ch == "\n") { i--; break; }
                }
                temp_st = ";; " + src_st.substring(i_start, i);
                token_push(51, temp_st);
                continue;
            }
            // ***** コメント「/* ～ */」のとき *****
            if (ch == "/" && ch2 == "*") {
                i++;
                while (i < src_st_len) {
                    // ***** 1文字取り出す *****
                    ch = src_st.charAt(i++);
                    if (i < src_st_len) { ch2 = src_st.charAt(i); } else { ch2 = ""; }
                    // ***** デリミタのとき *****
                    if (ch == "*" && ch2 == "/") { i++; break; }
                    // ***** 改行のとき *****
                    if (ch == "\r" || ch == "\n") {
                        line_no++;
                        if (ch == "\r" && ch2 == "\n") { i++; }
                        // token_push(0, "\n");
                    }
                }
                temp_st = "#| " + src_st.substring(i_start, i) + " |#";
                token_push(52, temp_st);
                continue;
            }
            // ***** 波括弧「{% ～ %}」のとき *****
            if (ch == "{" && ch2 == "%") {
                i++;
                while (i < src_st_len) {
                    // ***** 1文字取り出す *****
                    ch = src_st.charAt(i++);
                    if (i < src_st_len) { ch2 = src_st.charAt(i); } else { ch2 = ""; }
                    // ***** エスケープのとき *****
                    if (ch == "\\" && (ch2 == "\\" || ch2 == "{" || ch2 == "}" || ch2 == "%")) { i++; continue; }
                    // ***** デリミタのとき *****
                    if (ch == "%" && ch2 == "}") { i++; break; }
                    // ***** 改行のとき *****
                    if (ch == "\r" || ch == "\n") {
                        line_no++;
                        if (ch == "\r" && ch2 == "\n") { i++; }
                    }
                }
                // ***** 閉じ波括弧を外して登録 *****
                if (ch == "%" && ch2 == "}") { j = i - 2; } else { j = i; }
                if (i_start + 2 < j) { // 波括弧内が0文字なら登録しない
                    temp_st = src_st.substring(i_start, j)
                        .replace(/\\\{/g, "{")   // 「{」のエスケープ
                        .replace(/\\\}/g, "}")   // 「}」のエスケープ
                        .replace(/\\\%/g, "%")   // 「%」のエスケープ
                        .replace(/\\\\/g, "\\"); // 「\」のエスケープ ← これは最後にしないといけない
                    token_push(100, temp_st);
                }
                continue;
            }
            // ***** 文字列リテラル「" ～ "」のとき *****
            // ***** 文字列リテラル「' ～ '」のとき *****
            if (ch == '"' || ch == "'") {
                delim_ch = ch;
                while (i < src_st_len) {
                    // ***** 1文字取り出す *****
                    ch = src_st.charAt(i++);
                    if (i < src_st_len) { ch2 = src_st.charAt(i); } else { ch2 = ""; }
                    // ***** エスケープのとき *****
                    if (ch == "\\" && (ch2 == "\\" || ch2 == delim_ch)) { i++; continue; }
                    // ***** デリミタのとき *****
                    if (ch == delim_ch) { break; }
                    // ***** 改行のとき *****
                    if (ch == "\r" || ch == "\n") {
                        line_no++;
                        if (ch == "\r" && ch2 == "\n") { i++; }
                    }
                }
                // ***** 登録 *****
                token_push(100);
                continue;
            }
            // ***** 演算子のとき *****
            if (ch == "(" || ch == ")" || ch == "~" || ch == "?" || ch == ":" ||
                ch == ";" || ch == "," || ch == "{" || ch == "}" || ch == "[" || ch == "]") {
                token_push(100);
                continue;
            }
            if (ch == "=" || ch == "!" || ch == "^" || ch == "\\") {
                if (ch2 == "=") { i++; }
                token_push(100);
                continue;
            }
            if (ch == "+" || ch == "-" || ch == "*") {
                if (ch == "-" && ch2 == ">") { i++; }
                if (ch2 == ch) { i++; }
                if (ch2 == "=") { i++; }
                if (ch2 == ".") {
                    i++;
                    if (i < src_st_len && src_st.charAt(i) == "=") { i++; }
                }
                temp_st = src_st.substring(i_start, i);
                // ***** マイナス変換フラグONのとき *****
                // (-を+-に変換することで、多項式の変換結果を若干見やすくする)
                if (minus_conv) {
                    if (temp_st == "-") {
                        token_push(100, "+");
                    } else if (temp_st == "-.") {
                        token_push(100, "+.");
                    }
                }
                token_push(100, temp_st);
                continue;
            }
            if (ch == "/") {
                if (ch2 == "=") { i++; }
                if (ch2 == ".") {
                    i++;
                    if (i < src_st_len && src_st.charAt(i) == "=") { i++; }
                }
                token_push(100);
                continue;
            }
            if (ch == "<" || ch == ">" || ch == "%") {
                if (ch2 == "=") { i++; }
                if (ch2 == ch) {
                    i++;
                    if (i < src_st_len && src_st.charAt(i) == "=") { i++; }
                }
                token_push(100);
                continue;
            }
            if (ch == "&" || ch == "|") {
                if (ch2 == ch) { i++; }
                if (ch2 == "=") { i++; }
                token_push(100);
                continue;
            }
            // ***** その他のとき *****
            while (i < src_st_len) {
                // ***** 1文字取り出す *****
                ch = src_st.charAt(i);
                // ***** デリミタのとき *****
                // (ドットは入れない)
                if (" \t\r\n\"'()~?:;,=!^\\%+-*/<>&|{}[]".indexOf(ch) >= 0) { break; }
                // ***** その他のとき *****
                i++;
            }
            token_push(100);
        }
        // ***** 終端4個追加(安全のため) *****
        line_no_tk = line_no;
        token_push(100, "%end");
        token_push(100, "%end");
        token_push(100, "%end");
        token_push(100, "%end");
    }

    // ***** 演算子情報の生成 *****
    function make_optable() {
        var i;
        var op_obj = {};

        // ***** 演算子情報の生成 *****
        operator_table = {};
        for (i = 0; i < operator_data.length; i++) {
            op_obj = {};
            op_obj.funcname = operator_data[i][1];
            op_obj.priority = operator_data[i][2];
            op_obj.castflag = operator_data[i][3];
            operator_table[operator_data[i][0]] = op_obj;
        }
    }

    // ***** コード追加 *****
    function code_push(word, pos1, pos2) {
        var cd = {};
        cd.word = word;
        cd.pos1 = pos1;
        cd.pos2 = pos2;
        cd.opt = 0;
        code.push(cd);
    }

    // ***** コード挿入 *****
    function code_insert(i, word, pos1, pos2) {
        var cd = {};
        cd.word = word;
        cd.pos1 = pos1;
        cd.pos2 = pos2;
        cd.opt = 0;
        code.splice(i, 0, cd);
    }

    // ***** トークンの改行(+コメント)のスキップ *****
    function skip_line_feed(i, tok_end) {
        while (i < tok_end) {
            if (token[i].kind == 0  ||
                token[i].kind == 51 ||
                token[i].kind == 52) {
                i++;
                line_feed_num++;
                line_feed_code.push(token[i - 1].word);
                continue;
            }
            break;
        }
        return i;
    }

    // ***** コードの改行(+コメント)の出力 *****
    // (呼び出すタイミングに注意する(最適化処理と競合しないように))
    function output_line_feed(i) {
        var i2;
        if (line_feed) {
            for (i2 = 0; i2 < line_feed_num; i2++) {
                code_push(line_feed_code[i2], debugpos1, i);
            }
        }
        line_feed_num = 0;
        line_feed_code = [];
    }

    // ***** トークンの文字チェック *****
    function match2(ch, i, tok_end) {
        if (i >= tok_end) {
            debugpos2 = tok_end;
            throw new Error("'" + ch + "' が見つかりませんでした。");
        }
        if (ch != token[i].word) {
            debugpos2 = i + 1;
            throw new Error("'" + ch + "' があるべき所に '" + token[i].word + "' が見つかりました。");
        }
        // ***** 加算されないので注意 *****
        // i++;
    }

    // ***** 演算子検索 *****
    function op_func(op) {
        if (operator_table.hasOwnProperty(op)) {
            return operator_table[op].funcname;
        }
        throw new Error("未登録の演算子 '" + op + "' が見つかりました。");
    }
    function op_pri(op) {
        if (operator_table.hasOwnProperty(op)) {
            return operator_table[op].priority;
        }
        throw new Error("未登録の演算子 '" + op + "' が見つかりました。");
    }

    // ***** HTML文字列のエスケープ処理 *****
    function escape_html(html_st) {
        return html_st
            .replace(/&/g,   "&amp;")
            .replace(/[<]/g, "&lt;")
            .replace(/>/g,   "&gt;")
            .replace(/"/g,   "&quot;")
            .replace(/'/g,   "&#39;");
    }


})(SCPrefix || (SCPrefix = {}));


// -->
</script>
</head>

<body class="main_container">

<form action="#" onsubmit="convert_button(); return false;">
<table width="95%"><tr>
<th align="center" colspan="3">SCPrefix</th>
</tr><tr>
<th align="left" valign="top">src:</th>
<th align="left" width="95%"><textarea id="src_text1" cols="40" rows="10" style="width: 100%;"></textarea></th>
<th></th>
</tr><tr>
<th></th>
<th align="left"><input type="submit" value="convert"> &nbsp;
<input type="button" value="clear" onclick="clear_button();"> &nbsp;
<input type="checkbox" id="minus_conv">:「-」→「+-」 &nbsp;
<input type="checkbox" id="line_feed" checked>: line feed + comment</th>
<th></th>
</tr><tr>
<th align="left" valign="top">out:</th>
<th align="left" width="95%"><textarea id="out_text1" cols="40" rows="10" style="width: 100%;"></textarea></th>
<th></th>
</tr><tr>
<th></th>
<th align="left"><input type="button" value="sample1" onclick="sample_button(0);">
<input type="button" value="sample2" onclick="sample_button(1);">
<input type="button" value="sample3" onclick="sample_button(2);"></th>
<th></th>
</tr></table>
<pre><span id="debug_show1"></span></pre>
<pre><span id="result_show1"></span></pre>
</form>

</body>
</html>
